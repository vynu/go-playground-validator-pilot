// Package main provides a simplified modular validation server
// with multi-model support and clean architecture.
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"reflect"
	"time"

	httpswagger "github.com/swaggo/http-swagger"
	"goplayground-data-validator/registry"
)

// Global server start time for uptime tracking
var startTime = time.Now()

// main starts the modular validation server with optimized performance
func main() {
	// Default to modular server - clean, simplified architecture
	serverMode := os.Getenv("SERVER_MODE")

	if serverMode == "legacy" {
		log.Println("Starting Legacy Validation Server (deprecated)...")
		log.Println("Legacy mode is no longer supported - using modular server")
	}

	// Use the modular validation server by default
	log.Println("Starting Modular Validation Server...")
	startModularServer()
}

// startModularServer starts the optimized modular validation server with automatic endpoint registration
func startModularServer() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080" // Default port
	}

	// Create HTTP multiplexer with optimized routing
	mux := http.NewServeMux()

	// Register system endpoints
	mux.HandleFunc("GET /health", handleHealth)               // Health check endpoint
	mux.HandleFunc("POST /validate", handleGenericValidation) // Generic validation with model type
	mux.HandleFunc("GET /models", handleListModels)           // List available models

	// Register Swagger documentation endpoints
	mux.Handle("/swagger/", httpswagger.WrapHandler)           // Swagger UI
	mux.HandleFunc("GET /swagger/doc.json", handleSwaggerJSON) // Swagger JSON spec
	mux.HandleFunc("GET /swagger/models", handleSwaggerModels) // Dynamic model schemas

	// üöÄ UNIFIED AUTOMATIC REGISTRATION - Start the consolidated registration system
	log.Println("üîÑ Initializing unified automatic model registration...")

	// Start unified registration in a goroutine
	ctx := context.Background()
	go func() {
		if err := registry.StartRegistration(ctx, mux); err != nil {
			log.Printf("‚ùå Registration error: %v", err)
		}
	}()

	// Allow some time for initial model scanning
	time.Sleep(1 * time.Second)

	// Create optimized HTTP server
	server := &http.Server{
		Addr:    ":" + port,
		Handler: mux,
		// Optimized timeouts for production use
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	log.Printf("üöÄ Modular server starting on port %s", port)
	log.Printf("üìã Available endpoints:")
	log.Printf("  üìä GET  /health                - Server health check")
	log.Printf("  üîÑ POST /validate              - Generic validation with model type")
	log.Printf("  üìù GET  /models               - List available models")
	log.Printf("  üìö GET  /swagger/             - Swagger UI documentation")
	log.Printf("  üîç GET  /swagger/doc.json     - Swagger JSON specification")
	log.Printf("  üìÑ GET  /swagger/models       - Dynamic model schemas")
	log.Printf("")
	log.Printf("üéØ Platform-specific validation endpoints (AUTO-GENERATED):")

	// Dynamically list all registered model endpoints (after models are loaded)
	log.Printf("  üìÇ Dynamic endpoints will be listed after model discovery completes...")

	if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("Modular server failed to start: %v", err)
	}
}

// handleHealth provides optimized health check with minimal overhead
func handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Simple health response with uptime
	health := map[string]interface{}{
		"status":  "healthy",
		"version": "2.0.0-modular",
		"uptime":  time.Since(startTime).String(),
		"server":  "modular-validation-server",
	}

	json.NewEncoder(w).Encode(health)
}

// NOTE: Individual platform handlers (handleGitHubValidation, etc.)
// are no longer needed as they are automatically generated by the registry system.
// All platform-specific validation is now handled dynamically via registry.RegisterHTTPEndpoints()

// handleGenericValidation handles validation with explicit model type using automatic discovery
func handleGenericValidation(w http.ResponseWriter, r *http.Request) {
	var request struct {
		ModelType string                 `json:"model_type"`
		Payload   map[string]interface{} `json:"payload"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		sendJSONError(w, "Invalid JSON payload", http.StatusBadRequest)
		return
	}

	// Get the registry and check if model type is registered
	globalRegistry := registry.GetGlobalRegistry()
	modelType := registry.ModelType(request.ModelType)

	if !globalRegistry.IsRegistered(modelType) {
		sendJSONError(w, fmt.Sprintf("Model type '%s' is not registered", request.ModelType), http.StatusBadRequest)
		return
	}

	// Create an instance of the model struct
	modelInstance, err := globalRegistry.CreateModelInstance(modelType)
	if err != nil {
		sendJSONError(w, "Failed to create model instance: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Convert map to struct using JSON marshaling/unmarshaling
	jsonBytes, err := json.Marshal(request.Payload)
	if err != nil {
		sendJSONError(w, "Failed to serialize payload: "+err.Error(), http.StatusBadRequest)
		return
	}

	if err := json.Unmarshal(jsonBytes, modelInstance); err != nil {
		sendJSONError(w, "Failed to parse payload into model struct: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Dereference the pointer to get the actual struct value
	modelValue := reflect.ValueOf(modelInstance).Elem().Interface()

	// Validate using the registry
	result, err := globalRegistry.ValidatePayload(modelType, modelValue)
	if err != nil {
		sendJSONError(w, "Validation failed: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")

	// Check if result indicates invalid payload
	if resultMap, ok := result.(map[string]interface{}); ok {
		if isValid, exists := resultMap["is_valid"]; exists {
			if valid, ok := isValid.(bool); ok && !valid {
				w.WriteHeader(http.StatusUnprocessableEntity)
			}
		}
	}

	json.NewEncoder(w).Encode(result)
}

// handleListModels returns available model types dynamically
func handleListModels(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Try dynamic registry first
	dynamicRegistry := registry.GetGlobalDynamicRegistry()
	if dynamicRegistry != nil {
		modelsWithDetails := dynamicRegistry.GetRegisteredModelsWithDetails()
		json.NewEncoder(w).Encode(modelsWithDetails)
		return
	}

	// Fallback to standard registry
	standardRegistry := registry.GetGlobalRegistry()
	allModels := standardRegistry.GetAllModels()

	modelList := make([]string, 0, len(allModels))
	for modelType := range allModels {
		modelList = append(modelList, string(modelType))
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"models": modelList,
		"count":  len(modelList),
		"source": "standard_registry",
	})
}

// sendJSONError sends a standardized JSON error response
func sendJSONError(w http.ResponseWriter, message string, status int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error":  message,
		"status": status,
	})
}

// NOTE: The old hardcoded convert functions have been removed.
// All model type conversion is now handled automatically by the registry system
// using reflection and the universal converter in handleGenericValidation.

// handleSwaggerJSON serves the Swagger JSON specification
func handleSwaggerJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Read the swagger.yaml file and convert to JSON format
	swaggerSpec := getSwaggerSpec()
	json.NewEncoder(w).Encode(swaggerSpec)
}

// handleSwaggerModels returns dynamic model schemas based on registered models
func handleSwaggerModels(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Try dynamic registry first
	dynamicRegistry := registry.GetGlobalDynamicRegistry()
	if dynamicRegistry != nil {
		modelsWithDetails := dynamicRegistry.GetRegisteredModelsWithDetails()
		json.NewEncoder(w).Encode(modelsWithDetails)
		return
	}

	// Fallback to standard registry
	models := registry.GetGlobalRegistry().GetAllModels()

	// Create dynamic schemas for each model
	dynamicSchemas := make(map[string]interface{})
	for modelType, modelInfo := range models {
		dynamicSchemas[string(modelType)] = map[string]interface{}{
			"type":        "object",
			"description": modelInfo.Description,
			"version":     modelInfo.Version,
			"author":      modelInfo.Author,
			"tags":        modelInfo.Tags,
			"examples":    modelInfo.Examples,
			"created_at":  modelInfo.CreatedAt,
			"endpoint":    "/validate/" + string(modelType),
		}
	}

	response := map[string]interface{}{
		"models":      dynamicSchemas,
		"count":       len(dynamicSchemas),
		"last_update": time.Now().Format(time.RFC3339),
		"source":      "standard_registry",
	}

	json.NewEncoder(w).Encode(response)
}

// getSwaggerSpec returns the Swagger specification as a Go map
func getSwaggerSpec() map[string]interface{} {
	// Get dynamic model list
	var modelList []string

	// Try dynamic registry first
	dynamicRegistry := registry.GetGlobalDynamicRegistry()
	if dynamicRegistry != nil {
		allModels := dynamicRegistry.GetAllModels()
		modelList = make([]string, 0, len(allModels))
		for modelType := range allModels {
			modelList = append(modelList, string(modelType))
		}
	} else {
		// Fallback to standard registry
		models := registry.GetGlobalRegistry().ListModels()
		modelList = make([]string, len(models))
		for i, model := range models {
			modelList[i] = string(model)
		}
	}

	// Basic Swagger spec structure that will be populated from swagger.yaml
	return map[string]interface{}{
		"openapi": "3.0.3",
		"info": map[string]interface{}{
			"title":       "Modular Multi-Platform Validation API",
			"description": "A comprehensive modular validation server supporting multiple platforms and data formats.",
			"version":     "2.0.0-modular",
		},
		"servers": []map[string]interface{}{
			{"url": "http://localhost:8080", "description": "Development server"},
		},
		"paths": map[string]interface{}{
			"/health": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "Health check endpoint",
					"description": "Returns the current health status of the modular validation server",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Server is healthy",
						},
					},
				},
			},
			"/models": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "List available model types",
					"description": "Returns all available model types that can be validated",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Available model types",
						},
					},
				},
			},
		},
		"tags": []map[string]interface{}{
			{"name": "System", "description": "System health, status and model discovery"},
			{"name": "Platform Validation", "description": "Platform-specific validation endpoints"},
			{"name": "Generic Validation", "description": "Generic validation with automatic type conversion"},
		},
		"components": map[string]interface{}{
			"schemas": map[string]interface{}{
				"available_models": modelList,
			},
		},
	}
}
