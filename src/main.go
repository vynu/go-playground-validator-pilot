// Package main provides a simplified modular validation server
// with multi-model support and clean architecture.
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"reflect"
	"strings"
	"time"

	httpswagger "github.com/swaggo/http-swagger"
	"goplayground-data-validator/registry"
)

// Global server start time for uptime tracking
var startTime = time.Now()

// main starts the modular validation server with optimized performance
func main() {
	// Default to modular server - clean, simplified architecture
	serverMode := os.Getenv("SERVER_MODE")

	if serverMode == "legacy" {
		log.Println("Starting Legacy Validation Server (deprecated)...")
		log.Println("Legacy mode is no longer supported - using modular server")
	}

	// Use the modular validation server by default
	log.Println("Starting Modular Validation Server...")
	startModularServer()
}

// startModularServer starts the optimized modular validation server with automatic endpoint registration
func startModularServer() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080" // Default port
	}

	// Create HTTP multiplexer with optimized routing
	mux := http.NewServeMux()

	// Register system endpoints
	mux.HandleFunc("GET /health", handleHealth)               // Health check endpoint
	mux.HandleFunc("POST /validate", handleGenericValidation) // Generic validation with model type
	mux.HandleFunc("GET /models", handleListModels)           // List available models

	// Register Swagger documentation endpoints
	mux.Handle("/swagger/", httpswagger.WrapHandler)           // Swagger UI
	mux.HandleFunc("GET /swagger/doc.json", handleSwaggerJSON) // Swagger JSON spec
	mux.HandleFunc("GET /swagger/models", handleSwaggerModels) // Dynamic model schemas

	// 🚀 UNIFIED AUTOMATIC REGISTRATION - Start the consolidated registration system
	log.Println("🔄 Initializing unified automatic model registration...")

	// Start unified registration in a goroutine
	ctx := context.Background()
	go func() {
		if err := registry.StartRegistration(ctx, mux); err != nil {
			log.Printf("❌ Registration error: %v", err)
		}
	}()

	// Allow some time for initial model scanning
	time.Sleep(1 * time.Second)

	// Create optimized HTTP server
	server := &http.Server{
		Addr:    ":" + port,
		Handler: mux,
		// Optimized timeouts for production use
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	log.Printf("🚀 Modular server starting on port %s", port)
	log.Printf("📋 Available endpoints:")
	log.Printf("  📊 GET  /health                - Server health check")
	log.Printf("  🔄 POST /validate              - Generic validation with model type")
	log.Printf("  📝 GET  /models               - List available models")
	log.Printf("  📚 GET  /swagger/             - Swagger UI documentation")
	log.Printf("  🔍 GET  /swagger/doc.json     - Swagger JSON specification")
	log.Printf("  📄 GET  /swagger/models       - Dynamic model schemas")
	log.Printf("")
	log.Printf("🎯 Platform-specific validation endpoints (AUTO-GENERATED):")

	// Dynamically list all registered model endpoints (after models are loaded)
	log.Printf("  📂 Dynamic endpoints will be listed after model discovery completes...")

	if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("Modular server failed to start: %v", err)
	}
}

// handleHealth provides optimized health check with minimal overhead
func handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Simple health response with uptime
	health := map[string]interface{}{
		"status":  "healthy",
		"version": "2.0.0-modular",
		"uptime":  time.Since(startTime).String(),
		"server":  "modular-validation-server",
	}

	json.NewEncoder(w).Encode(health)
}

// NOTE: Individual platform handlers (handleGitHubValidation, etc.)
// are no longer needed as they are automatically generated by the registry system.
// All platform-specific validation is now handled dynamically via registry.RegisterHTTPEndpoints()

// handleGenericValidation handles validation with explicit model type using automatic discovery
// Supports both single object validation (payload) and array validation (data)
func handleGenericValidation(w http.ResponseWriter, r *http.Request) {
	// Ensure request body is closed and cleaned up
	defer r.Body.Close()

	var request struct {
		ModelType string                   `json:"model_type"`
		Payload   map[string]interface{}   `json:"payload"`             // Single object validation
		Data      []map[string]interface{} `json:"data,omitempty"`      // Array validation
		Threshold *float64                 `json:"threshold,omitempty"` // Optional threshold percentage for batch validation
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		sendJSONError(w, "Invalid JSON payload", http.StatusBadRequest)
		return
	}

	// Get the registry and check if model type is registered
	globalRegistry := registry.GetGlobalRegistry()
	modelType := registry.ModelType(request.ModelType)

	if !globalRegistry.IsRegistered(modelType) {
		sendJSONError(w, fmt.Sprintf("Model type '%s' is not registered", request.ModelType), http.StatusBadRequest)
		return
	}

	// NEW: Detect array vs single object validation
	if len(request.Data) > 0 {
		// Array validation path
		result, err := globalRegistry.ValidateArray(modelType, request.Data, request.Threshold)
		if err != nil {
			sendJSONError(w, "Array validation failed: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")

		// Set appropriate status code based on validation status
		// "success" = all validation passed threshold, "failed" = below threshold
		if result.Status == "failed" {
			w.WriteHeader(http.StatusUnprocessableEntity)
		}

		json.NewEncoder(w).Encode(result)
		return
	}

	// Existing single object validation
	// Create an instance of the model struct
	modelInstance, err := globalRegistry.CreateModelInstance(modelType)
	if err != nil {
		sendJSONError(w, "Failed to create model instance: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Convert map to struct using optimized direct conversion
	if err := convertMapToStruct(request.Payload, modelInstance); err != nil {
		sendJSONError(w, "Failed to parse payload into model struct: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Dereference the pointer to get the actual struct value
	modelValue := reflect.ValueOf(modelInstance).Elem().Interface()

	// Validate using the registry
	result, err := globalRegistry.ValidatePayload(modelType, modelValue)
	if err != nil {
		sendJSONError(w, "Validation failed: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")

	// Check if result indicates invalid payload
	if resultMap, ok := result.(map[string]interface{}); ok {
		if isValid, exists := resultMap["is_valid"]; exists {
			if valid, ok := isValid.(bool); ok && !valid {
				w.WriteHeader(http.StatusUnprocessableEntity)
			}
		}
	}

	json.NewEncoder(w).Encode(result)
}

// handleListModels returns available model types dynamically
func handleListModels(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	modelsWithDetails := registry.GetGlobalRegistry().GetRegisteredModelsWithDetails()
	json.NewEncoder(w).Encode(modelsWithDetails)
}

// sendJSONError sends a standardized JSON error response
func sendJSONError(w http.ResponseWriter, message string, status int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error":  message,
		"status": status,
	})
}

// convertMapToStruct efficiently converts a map to a struct using reflection
// This replaces the inefficient JSON marshal/unmarshal pattern
func convertMapToStruct(src map[string]interface{}, dest interface{}) error {
	destValue := reflect.ValueOf(dest)
	if destValue.Kind() != reflect.Ptr || destValue.Elem().Kind() != reflect.Struct {
		return fmt.Errorf("destination must be a pointer to a struct")
	}

	destValue = destValue.Elem()
	destType := destValue.Type()

	for i := 0; i < destValue.NumField(); i++ {
		field := destValue.Field(i)
		fieldType := destType.Field(i)

		// Skip unexported fields
		if !field.CanSet() {
			continue
		}

		// Get the JSON tag name, fall back to field name
		jsonTag := fieldType.Tag.Get("json")
		if jsonTag == "" || jsonTag == "-" {
			continue
		}

		// Handle json tag with options like "field_name,omitempty"
		fieldName := strings.Split(jsonTag, ",")[0]
		if fieldName == "" {
			fieldName = fieldType.Name
		}

		// Get value from source map
		srcValue, exists := src[fieldName]
		if !exists {
			continue
		}

		// Convert and set the value
		if err := setFieldValue(field, srcValue); err != nil {
			return fmt.Errorf("failed to set field %s: %v", fieldName, err)
		}
	}

	return nil
}

// setFieldValue sets a reflect.Value with type conversion
func setFieldValue(field reflect.Value, value interface{}) error {
	if value == nil {
		return nil
	}

	srcValue := reflect.ValueOf(value)
	fieldType := field.Type()

	// Direct assignment if types match
	if srcValue.Type().AssignableTo(fieldType) {
		field.Set(srcValue)
		return nil
	}

	// Handle type conversions
	switch fieldType.Kind() {
	case reflect.String:
		if str, ok := value.(string); ok {
			field.SetString(str)
		} else {
			field.SetString(fmt.Sprintf("%v", value))
		}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		if num, ok := convertToInt64(value); ok {
			if field.OverflowInt(num) {
				return fmt.Errorf("integer overflow for value %v", value)
			}
			field.SetInt(num)
		} else {
			return fmt.Errorf("cannot convert %v to integer", value)
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		if num, ok := convertToUint64(value); ok {
			if field.OverflowUint(num) {
				return fmt.Errorf("unsigned integer overflow for value %v", value)
			}
			field.SetUint(num)
		} else {
			return fmt.Errorf("cannot convert %v to unsigned integer", value)
		}
	case reflect.Float32, reflect.Float64:
		if num, ok := convertToFloat64(value); ok {
			if field.OverflowFloat(num) {
				return fmt.Errorf("float overflow for value %v", value)
			}
			field.SetFloat(num)
		} else {
			return fmt.Errorf("cannot convert %v to float", value)
		}
	case reflect.Bool:
		if b, ok := value.(bool); ok {
			field.SetBool(b)
		} else {
			return fmt.Errorf("cannot convert %v to bool", value)
		}
	case reflect.Slice:
		return setSliceValue(field, value)
	case reflect.Map:
		return setMapValue(field, value)
	default:
		// Fall back to JSON conversion for complex types
		jsonBytes, err := json.Marshal(value)
		if err != nil {
			return err
		}
		return json.Unmarshal(jsonBytes, field.Addr().Interface())
	}

	return nil
}

// Helper functions for type conversion
func convertToInt64(value interface{}) (int64, bool) {
	switch v := value.(type) {
	case int:
		return int64(v), true
	case int8:
		return int64(v), true
	case int16:
		return int64(v), true
	case int32:
		return int64(v), true
	case int64:
		return v, true
	case float32:
		return int64(v), true
	case float64:
		return int64(v), true
	case string:
		if i, err := fmt.Sscanf(v, "%d", new(int64)); err == nil && i == 1 {
			var result int64
			fmt.Sscanf(v, "%d", &result)
			return result, true
		}
	}
	return 0, false
}

func convertToUint64(value interface{}) (uint64, bool) {
	switch v := value.(type) {
	case uint:
		return uint64(v), true
	case uint8:
		return uint64(v), true
	case uint16:
		return uint64(v), true
	case uint32:
		return uint64(v), true
	case uint64:
		return v, true
	case int:
		if v >= 0 {
			return uint64(v), true
		}
	case int64:
		if v >= 0 {
			return uint64(v), true
		}
	case float64:
		if v >= 0 {
			return uint64(v), true
		}
	}
	return 0, false
}

func convertToFloat64(value interface{}) (float64, bool) {
	switch v := value.(type) {
	case float32:
		return float64(v), true
	case float64:
		return v, true
	case int:
		return float64(v), true
	case int64:
		return float64(v), true
	case uint64:
		return float64(v), true
	case string:
		if f, err := fmt.Sscanf(v, "%f", new(float64)); err == nil && f == 1 {
			var result float64
			fmt.Sscanf(v, "%f", &result)
			return result, true
		}
	}
	return 0, false
}

func setSliceValue(field reflect.Value, value interface{}) error {
	srcSlice := reflect.ValueOf(value)
	if srcSlice.Kind() != reflect.Slice {
		return fmt.Errorf("source is not a slice")
	}

	sliceType := field.Type()
	newSlice := reflect.MakeSlice(sliceType, srcSlice.Len(), srcSlice.Len())

	for i := 0; i < srcSlice.Len(); i++ {
		if err := setFieldValue(newSlice.Index(i), srcSlice.Index(i).Interface()); err != nil {
			return err
		}
	}

	field.Set(newSlice)
	return nil
}

func setMapValue(field reflect.Value, value interface{}) error {
	srcMap := reflect.ValueOf(value)
	if srcMap.Kind() != reflect.Map {
		return fmt.Errorf("source is not a map")
	}

	mapType := field.Type()
	newMap := reflect.MakeMap(mapType)

	for _, key := range srcMap.MapKeys() {
		mapValue := srcMap.MapIndex(key)
		newValue := reflect.New(mapType.Elem()).Elem()

		if err := setFieldValue(newValue, mapValue.Interface()); err != nil {
			return err
		}

		newMap.SetMapIndex(key, newValue)
	}

	field.Set(newMap)
	return nil
}

// handleSwaggerJSON serves the Swagger JSON specification
func handleSwaggerJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Read the swagger.yaml file and convert to JSON format
	swaggerSpec := getSwaggerSpec()
	json.NewEncoder(w).Encode(swaggerSpec)
}

// handleSwaggerModels returns dynamic model schemas based on registered models
func handleSwaggerModels(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	modelsWithDetails := registry.GetGlobalRegistry().GetRegisteredModelsWithDetails()
	json.NewEncoder(w).Encode(modelsWithDetails)
}

// getSwaggerSpec returns the Swagger specification as a Go map
func getSwaggerSpec() map[string]interface{} {
	// Get model list from registry
	models := registry.GetGlobalRegistry().ListModels()
	modelList := make([]string, len(models))
	for i, model := range models {
		modelList[i] = string(model)
	}

	// Basic Swagger spec structure
	return map[string]interface{}{
		"openapi": "3.0.3",
		"info": map[string]interface{}{
			"title":       "Modular Multi-Platform Validation API",
			"description": "A comprehensive modular validation server supporting multiple platforms and data formats.",
			"version":     "2.0.0-modular",
		},
		"servers": []map[string]interface{}{
			{"url": "http://localhost:8080", "description": "Development server"},
		},
		"paths": map[string]interface{}{
			"/health": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "Health check endpoint",
					"description": "Returns the current health status of the modular validation server",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Server is healthy",
							"content": map[string]interface{}{
								"application/json": map[string]interface{}{
									"schema": map[string]interface{}{
										"$ref": "#/components/schemas/HealthResponse",
									},
								},
							},
						},
					},
				},
			},
			"/models": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "List available model types",
					"description": "Returns all available model types that can be validated",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Available model types",
							"content": map[string]interface{}{
								"application/json": map[string]interface{}{
									"schema": map[string]interface{}{
										"$ref": "#/components/schemas/ModelsResponse",
									},
								},
							},
						},
					},
				},
			},
			"/validate": map[string]interface{}{
				"post": map[string]interface{}{
					"summary":     "Validate single object or array of objects",
					"description": "Validates a single object or an array of objects with optional threshold-based validation. Supports both single object validation (payload field) and batch validation (data field). For batch validation, you can optionally specify a threshold percentage for success criteria.",
					"tags":        []string{"Generic Validation"},
					"requestBody": map[string]interface{}{
						"required": true,
						"content": map[string]interface{}{
							"application/json": map[string]interface{}{
								"schema": map[string]interface{}{
									"oneOf": []map[string]interface{}{
										{"$ref": "#/components/schemas/SingleValidationRequest"},
										{"$ref": "#/components/schemas/ArrayValidationRequest"},
									},
								},
								"examples": map[string]interface{}{
									"single_object": map[string]interface{}{
										"summary": "Single object validation",
										"value": map[string]interface{}{
											"model_type": "incident",
											"payload": map[string]interface{}{
												"id":          "INC-20240115-0001",
												"title":       "Test Incident",
												"description": "Testing single object validation",
												"priority":    5,
												"severity":    "critical",
												"status":      "open",
											},
										},
									},
									"array_validation": map[string]interface{}{
										"summary": "Array validation without threshold",
										"value": map[string]interface{}{
											"model_type": "incident",
											"data": []map[string]interface{}{
												{
													"id":       "INC-20240115-0001",
													"title":    "Incident 1",
													"priority": 5,
													"severity": "critical",
													"status":   "open",
												},
												{
													"id":       "INC-20240115-0002",
													"title":    "Incident 2",
													"priority": 3,
													"severity": "high",
													"status":   "open",
												},
											},
										},
									},
									"threshold_validation": map[string]interface{}{
										"summary": "Array validation with 20% threshold",
										"value": map[string]interface{}{
											"model_type": "incident",
											"threshold":  20.0,
											"data": []map[string]interface{}{
												{
													"id":       "INC-20240115-0001",
													"title":    "Valid Incident",
													"priority": 5,
													"severity": "critical",
													"status":   "open",
												},
												{
													"id":       "INVALID",
													"title":    "",
													"priority": 999,
												},
											},
										},
									},
								},
							},
						},
					},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Single object validation result",
							"content": map[string]interface{}{
								"application/json": map[string]interface{}{
									"schema": map[string]interface{}{
										"$ref": "#/components/schemas/ValidationResult",
									},
								},
							},
						},
						"422": map[string]interface{}{
							"description": "Array validation result (status: failed when threshold not met)",
							"content": map[string]interface{}{
								"application/json": map[string]interface{}{
									"schema": map[string]interface{}{
										"$ref": "#/components/schemas/ArrayValidationResult",
									},
								},
							},
						},
						"400": map[string]interface{}{
							"description": "Bad request - invalid model type or malformed payload",
						},
						"500": map[string]interface{}{
							"description": "Internal server error",
						},
					},
				},
			},
		},
		"tags": []map[string]interface{}{
			{"name": "System", "description": "System health, status and model discovery"},
			{"name": "Generic Validation", "description": "Generic validation endpoint supporting all model types with single object and array/batch validation"},
		},
		"components": map[string]interface{}{
			"schemas": map[string]interface{}{
				"AvailableModels": map[string]interface{}{
					"type":        "array",
					"description": "List of available model types that can be validated",
					"items": map[string]interface{}{
						"type": "string",
						"enum": modelList,
					},
					"example": modelList,
				},
				"HealthResponse": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"status":  map[string]interface{}{"type": "string", "example": "healthy"},
						"version": map[string]interface{}{"type": "string", "example": "2.0.0-modular"},
						"uptime":  map[string]interface{}{"type": "string", "example": "1h30m45s"},
						"server":  map[string]interface{}{"type": "string", "example": "modular-validation-server"},
					},
				},
				"ModelsResponse": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"count":  map[string]interface{}{"type": "integer", "example": 6},
						"source": map[string]interface{}{"type": "string", "example": "unified-registry"},
						"models": map[string]interface{}{
							"type":                 "object",
							"additionalProperties": map[string]interface{}{"$ref": "#/components/schemas/ModelInfo"},
						},
					},
				},
				"ModelInfo": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"name":        map[string]interface{}{"type": "string", "example": "Incident Report"},
						"description": map[string]interface{}{"type": "string", "example": "Incident report validation with operational context"},
						"version":     map[string]interface{}{"type": "string", "example": "1.0.0"},
						"author":      map[string]interface{}{"type": "string", "example": "Unified Auto-Registry"},
						"endpoint":    map[string]interface{}{"type": "string", "example": "/validate/incident"},
						"tags":        map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
						"created_at":  map[string]interface{}{"type": "string", "format": "date-time"},
					},
				},
				"SingleValidationRequest": map[string]interface{}{
					"type":     "object",
					"required": []string{"model_type", "payload"},
					"properties": map[string]interface{}{
						"model_type": map[string]interface{}{
							"type":        "string",
							"description": "The type of model to validate",
							"enum":        modelList,
							"example":     "incident",
						},
						"payload": map[string]interface{}{
							"type":        "object",
							"description": "The object to validate",
							"example": map[string]interface{}{
								"id":          "INC-20240115-0001",
								"title":       "Test Incident",
								"description": "Testing validation",
								"priority":    5,
								"severity":    "critical",
								"status":      "open",
							},
						},
					},
				},
				"ArrayValidationRequest": map[string]interface{}{
					"type":     "object",
					"required": []string{"model_type", "data"},
					"properties": map[string]interface{}{
						"model_type": map[string]interface{}{
							"type":        "string",
							"description": "The type of model to validate",
							"enum":        modelList,
							"example":     "incident",
						},
						"data": map[string]interface{}{
							"type":        "array",
							"description": "Array of objects to validate",
							"items":       map[string]interface{}{"type": "object"},
							"example": []map[string]interface{}{
								{
									"id":       "INC-20240115-0001",
									"title":    "Incident 1",
									"priority": 5,
								},
								{
									"id":       "INC-20240115-0002",
									"title":    "Incident 2",
									"priority": 3,
								},
							},
						},
						"threshold": map[string]interface{}{
							"type":        "number",
							"format":      "float",
							"description": "Optional threshold percentage (0-100) for success criteria. Success rate must be >= threshold for status 'success'. For example, threshold of 20.0 means at least 20% of records must be valid.",
							"minimum":     0,
							"maximum":     100,
							"example":     20.0,
						},
					},
				},
				"ValidationResult": map[string]interface{}{
					"type":        "object",
					"description": "Single object validation result",
					"properties": map[string]interface{}{
						"is_valid": map[string]interface{}{
							"type":        "boolean",
							"description": "Whether the payload is valid",
							"example":     true,
						},
						"model_type": map[string]interface{}{
							"type":        "string",
							"description": "The model type that was validated",
							"example":     "incident",
						},
						"provider": map[string]interface{}{
							"type":        "string",
							"description": "The validation provider used",
							"example":     "go-playground",
						},
						"errors": map[string]interface{}{
							"type":        "array",
							"description": "List of validation errors (empty if valid)",
							"items":       map[string]interface{}{"$ref": "#/components/schemas/ValidationError"},
						},
						"warnings": map[string]interface{}{
							"type":        "array",
							"description": "List of validation warnings (business logic warnings)",
							"items":       map[string]interface{}{"$ref": "#/components/schemas/ValidationWarning"},
						},
					},
				},
				"ArrayValidationResult": map[string]interface{}{
					"type":        "object",
					"description": "Array/batch validation result with optional threshold-based status",
					"properties": map[string]interface{}{
						"batch_id": map[string]interface{}{
							"type":        "string",
							"description": "Auto-generated batch identifier",
							"example":     "auto_abc123xyz",
						},
						"status": map[string]interface{}{
							"type":        "string",
							"description": "Overall batch status: 'success' if threshold met or no threshold, 'failed' if below threshold",
							"enum":        []string{"success", "failed"},
							"example":     "success",
						},
						"total_records": map[string]interface{}{
							"type":        "integer",
							"description": "Total number of records validated",
							"example":     10,
						},
						"valid_records": map[string]interface{}{
							"type":        "integer",
							"description": "Number of valid records",
							"example":     8,
						},
						"invalid_records": map[string]interface{}{
							"type":        "integer",
							"description": "Number of invalid records",
							"example":     2,
						},
						"warning_records": map[string]interface{}{
							"type":        "integer",
							"description": "Number of records with warnings only",
							"example":     1,
						},
						"threshold": map[string]interface{}{
							"type":        "number",
							"format":      "float",
							"description": "The threshold percentage that was applied (if any)",
							"example":     20.0,
						},
						"processing_time_ms": map[string]interface{}{
							"type":        "integer",
							"description": "Processing time in milliseconds",
							"example":     125,
						},
						"completed_at": map[string]interface{}{
							"type":        "string",
							"format":      "date-time",
							"description": "Timestamp when validation completed",
						},
						"summary": map[string]interface{}{
							"type":        "object",
							"description": "Summary statistics",
							"$ref":        "#/components/schemas/ValidationSummary",
						},
						"results": map[string]interface{}{
							"type":        "array",
							"description": "Individual row results (only invalid rows and rows with warnings - valid rows without warnings are excluded)",
							"items":       map[string]interface{}{"$ref": "#/components/schemas/RowValidationResult"},
						},
					},
				},
				"ValidationSummary": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"success_rate": map[string]interface{}{
							"type":        "number",
							"format":      "float",
							"description": "Success rate percentage (valid_records / total_records * 100)",
							"example":     80.0,
						},
						"validation_errors": map[string]interface{}{
							"type":        "integer",
							"description": "Total number of validation errors across all records",
							"example":     5,
						},
						"validation_warnings": map[string]interface{}{
							"type":        "integer",
							"description": "Total number of validation warnings across all records",
							"example":     2,
						},
						"total_records_processed": map[string]interface{}{
							"type":        "integer",
							"description": "Total records processed",
							"example":     10,
						},
					},
				},
				"RowValidationResult": map[string]interface{}{
					"type":        "object",
					"description": "Individual row validation result (only included if invalid or has warnings)",
					"properties": map[string]interface{}{
						"row_index": map[string]interface{}{
							"type":        "integer",
							"description": "Zero-based index of the row in the input array",
							"example":     2,
						},
						"record_identifier": map[string]interface{}{
							"type":        "string",
							"description": "Identifier extracted from the record (e.g., ID field)",
							"example":     "INC-20240115-0003",
						},
						"is_valid": map[string]interface{}{
							"type":        "boolean",
							"description": "Whether this row is valid",
							"example":     false,
						},
						"validation_time_ms": map[string]interface{}{
							"type":        "integer",
							"description": "Time taken to validate this row in milliseconds",
							"example":     5,
						},
						"errors": map[string]interface{}{
							"type":        "array",
							"description": "Validation errors for this row",
							"items":       map[string]interface{}{"$ref": "#/components/schemas/ValidationError"},
						},
						"warnings": map[string]interface{}{
							"type":        "array",
							"description": "Validation warnings for this row",
							"items":       map[string]interface{}{"$ref": "#/components/schemas/ValidationWarning"},
						},
					},
				},
				"ValidationError": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"field": map[string]interface{}{
							"type":        "string",
							"description": "The field that failed validation",
							"example":     "priority",
						},
						"message": map[string]interface{}{
							"type":        "string",
							"description": "Human-readable error message",
							"example":     "Priority must be between 1 and 5",
						},
						"code": map[string]interface{}{
							"type":        "string",
							"description": "Error code for programmatic handling",
							"example":     "VALUE_OUT_OF_RANGE",
						},
					},
				},
				"ValidationWarning": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"field": map[string]interface{}{
							"type":        "string",
							"description": "The field that triggered the warning",
							"example":     "status",
						},
						"message": map[string]interface{}{
							"type":        "string",
							"description": "Human-readable warning message",
							"example":     "Incident is older than 90 days",
						},
						"code": map[string]interface{}{
							"type":        "string",
							"description": "Warning code for programmatic handling",
							"example":     "STALE_INCIDENT",
						},
					},
				},
			},
		},
	}
}
