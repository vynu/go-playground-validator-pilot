// Package main provides a simplified modular validation server
// with multi-model support and clean architecture.
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"time"

	"github-data-validator/models"
	"github-data-validator/registry"
	httpswagger "github.com/swaggo/http-swagger"
)

// Global server start time for uptime tracking
var startTime = time.Now()

// main starts the modular validation server with optimized performance
func main() {
	// Default to modular server - clean, simplified architecture
	serverMode := os.Getenv("SERVER_MODE")

	if serverMode == "legacy" {
		log.Println("Starting Legacy Validation Server (deprecated)...")
		log.Println("Legacy mode is no longer supported - using modular server")
	}

	// Use the modular validation server by default
	log.Println("Starting Modular Validation Server...")
	startModularServer()
}

// startModularServer starts the optimized modular validation server with automatic endpoint registration
func startModularServer() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080" // Default port
	}

	// Create HTTP multiplexer with optimized routing
	mux := http.NewServeMux()

	// Register system endpoints
	mux.HandleFunc("GET /health", handleHealth)               // Health check endpoint
	mux.HandleFunc("POST /validate", handleGenericValidation) // Generic validation with model type
	mux.HandleFunc("GET /models", handleListModels)           // List available models

	// Register Swagger documentation endpoints
	mux.Handle("/swagger/", httpswagger.WrapHandler)           // Swagger UI
	mux.HandleFunc("GET /swagger/doc.json", handleSwaggerJSON) // Swagger JSON spec
	mux.HandleFunc("GET /swagger/models", handleSwaggerModels) // Dynamic model schemas

	// üöÄ AUTOMATIC ENDPOINT REGISTRATION - Register HTTP endpoints for ALL registered models
	log.Println("üîÑ Initializing automatic endpoint registration system...")
	modelRegistry := registry.GetGlobalRegistry()
	modelRegistry.RegisterHTTPEndpoints(mux)

	// Create optimized HTTP server
	server := &http.Server{
		Addr:    ":" + port,
		Handler: mux,
		// Optimized timeouts for production use
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	log.Printf("üöÄ Modular server starting on port %s", port)
	log.Printf("üìã Available endpoints:")
	log.Printf("  üìä GET  /health                - Server health check")
	log.Printf("  üîÑ POST /validate              - Generic validation with model type")
	log.Printf("  üìù GET  /models               - List available models")
	log.Printf("  üìö GET  /swagger/             - Swagger UI documentation")
	log.Printf("  üîç GET  /swagger/doc.json     - Swagger JSON specification")
	log.Printf("  üìÑ GET  /swagger/models       - Dynamic model schemas")
	log.Printf("")
	log.Printf("üéØ Platform-specific validation endpoints (AUTO-GENERATED):")

	// Dynamically list all registered model endpoints
	allModels := modelRegistry.GetAllModels()
	for modelType, modelInfo := range allModels {
		log.Printf("  ‚úÖ POST /validate/%-10s - %s", string(modelType), modelInfo.Name)
	}

	if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("Modular server failed to start: %v", err)
	}
}

// handleHealth provides optimized health check with minimal overhead
func handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Simple health response with uptime
	health := map[string]interface{}{
		"status":  "healthy",
		"version": "2.0.0-modular",
		"uptime":  time.Since(startTime).String(),
		"server":  "modular-validation-server",
	}

	json.NewEncoder(w).Encode(health)
}

// NOTE: Individual platform handlers (handleGitHubValidation, handleGitLabValidation, etc.)
// are no longer needed as they are automatically generated by the registry system.
// All platform-specific validation is now handled dynamically via registry.RegisterHTTPEndpoints()

// handleGenericValidation handles validation with explicit model type
// Fixed to properly convert JSON map to typed structs
func handleGenericValidation(w http.ResponseWriter, r *http.Request) {
	var request struct {
		ModelType string                 `json:"model_type"`
		Payload   map[string]interface{} `json:"payload"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		sendJSONError(w, "Invalid JSON payload", http.StatusBadRequest)
		return
	}

	// Convert map to appropriate struct type based on model_type
	var typedPayload interface{}
	var err error

	switch request.ModelType {
	case "github":
		typedPayload, err = convertMapToGitHub(request.Payload)
	case "gitlab":
		typedPayload, err = convertMapToGitLab(request.Payload)
	case "bitbucket":
		typedPayload, err = convertMapToBitbucket(request.Payload)
	case "slack":
		typedPayload, err = convertMapToSlack(request.Payload)
	default:
		sendJSONError(w, "Unsupported model type", http.StatusBadRequest)
		return
	}

	if err != nil {
		sendJSONError(w, "Failed to parse payload: "+err.Error(), http.StatusBadRequest)
		return
	}

	modelType := registry.ModelType(request.ModelType)
	result, err := registry.ValidateWithManager(modelType, typedPayload, nil)
	if err != nil {
		sendJSONError(w, "Validation failed", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if !result.IsValid {
		w.WriteHeader(http.StatusUnprocessableEntity)
	}
	json.NewEncoder(w).Encode(result)
}

// handleListModels returns available model types
func handleListModels(w http.ResponseWriter, r *http.Request) {
	models := []string{
		string(registry.ModelTypeGitHub),
		string(registry.ModelTypeGitLab),
		string(registry.ModelTypeBitbucket),
		string(registry.ModelTypeSlack),
		string(registry.ModelTypeAPI),
		string(registry.ModelTypeDatabase),
		string(registry.ModelTypeGeneric),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"models": models,
		"count":  len(models),
	})
}

// sendJSONError sends a standardized JSON error response
func sendJSONError(w http.ResponseWriter, message string, status int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error":  message,
		"status": status,
	})
}

// Helper functions to convert maps to typed structs
// These fix the generic endpoint type conversion issue

func convertMapToGitHub(data map[string]interface{}) (models.GitHubPayload, error) {
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		return models.GitHubPayload{}, err
	}

	var payload models.GitHubPayload
	err = json.Unmarshal(jsonBytes, &payload)
	return payload, err
}

func convertMapToGitLab(data map[string]interface{}) (models.GitLabPayload, error) {
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		return models.GitLabPayload{}, err
	}

	var payload models.GitLabPayload
	err = json.Unmarshal(jsonBytes, &payload)
	return payload, err
}

func convertMapToBitbucket(data map[string]interface{}) (models.BitbucketPayload, error) {
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		return models.BitbucketPayload{}, err
	}

	var payload models.BitbucketPayload
	err = json.Unmarshal(jsonBytes, &payload)
	return payload, err
}

func convertMapToSlack(data map[string]interface{}) (models.SlackMessagePayload, error) {
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		return models.SlackMessagePayload{}, err
	}

	var payload models.SlackMessagePayload
	err = json.Unmarshal(jsonBytes, &payload)
	return payload, err
}

// handleSwaggerJSON serves the Swagger JSON specification
func handleSwaggerJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Read the swagger.yaml file and convert to JSON format
	swaggerSpec := getSwaggerSpec()
	json.NewEncoder(w).Encode(swaggerSpec)
}

// handleSwaggerModels returns dynamic model schemas based on registered models
func handleSwaggerModels(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Get all registered models from the registry
	models := registry.GetGlobalRegistry().GetAllModels()

	// Create dynamic schemas for each model
	dynamicSchemas := make(map[string]interface{})
	for modelType, modelInfo := range models {
		dynamicSchemas[string(modelType)] = map[string]interface{}{
			"type":        "object",
			"description": modelInfo.Description,
			"version":     modelInfo.Version,
			"author":      modelInfo.Author,
			"tags":        modelInfo.Tags,
			"examples":    modelInfo.Examples,
			"created_at":  modelInfo.CreatedAt,
		}
	}

	response := map[string]interface{}{
		"models":      dynamicSchemas,
		"count":       len(dynamicSchemas),
		"last_update": time.Now().Format(time.RFC3339),
	}

	json.NewEncoder(w).Encode(response)
}

// getSwaggerSpec returns the Swagger specification as a Go map
func getSwaggerSpec() map[string]interface{} {
	// Get dynamic model list
	models := registry.GetGlobalRegistry().ListModels()
	modelList := make([]string, len(models))
	for i, model := range models {
		modelList[i] = string(model)
	}

	// Basic Swagger spec structure that will be populated from swagger.yaml
	return map[string]interface{}{
		"openapi": "3.0.3",
		"info": map[string]interface{}{
			"title":       "Modular Multi-Platform Validation API",
			"description": "A comprehensive modular validation server supporting multiple platforms and data formats.",
			"version":     "2.0.0-modular",
		},
		"servers": []map[string]interface{}{
			{"url": "http://localhost:8080", "description": "Development server"},
		},
		"paths": map[string]interface{}{
			"/health": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "Health check endpoint",
					"description": "Returns the current health status of the modular validation server",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Server is healthy",
						},
					},
				},
			},
			"/models": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "List available model types",
					"description": "Returns all available model types that can be validated",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Available model types",
						},
					},
				},
			},
		},
		"tags": []map[string]interface{}{
			{"name": "System", "description": "System health, status and model discovery"},
			{"name": "Platform Validation", "description": "Platform-specific validation endpoints"},
			{"name": "Generic Validation", "description": "Generic validation with automatic type conversion"},
		},
		"components": map[string]interface{}{
			"schemas": map[string]interface{}{
				"available_models": modelList,
			},
		},
	}
}
