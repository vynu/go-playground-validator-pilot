// Package main provides a simplified modular validation server
// with multi-model support and clean architecture.
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"reflect"
	"strings"
	"time"

	httpswagger "github.com/swaggo/http-swagger"
	"goplayground-data-validator/registry"
)

// Global server start time for uptime tracking
var startTime = time.Now()

// main starts the modular validation server with optimized performance
func main() {
	// Default to modular server - clean, simplified architecture
	serverMode := os.Getenv("SERVER_MODE")

	if serverMode == "legacy" {
		log.Println("Starting Legacy Validation Server (deprecated)...")
		log.Println("Legacy mode is no longer supported - using modular server")
	}

	// Use the modular validation server by default
	log.Println("Starting Modular Validation Server...")
	startModularServer()
}

// startModularServer starts the optimized modular validation server with automatic endpoint registration
func startModularServer() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080" // Default port
	}

	// Create HTTP multiplexer with optimized routing
	mux := http.NewServeMux()

	// Register system endpoints
	mux.HandleFunc("GET /health", handleHealth)               // Health check endpoint
	mux.HandleFunc("POST /validate", handleGenericValidation) // Generic validation with model type
	mux.HandleFunc("GET /models", handleListModels)           // List available models

	// Register Swagger documentation endpoints
	mux.Handle("/swagger/", httpswagger.WrapHandler)           // Swagger UI
	mux.HandleFunc("GET /swagger/doc.json", handleSwaggerJSON) // Swagger JSON spec
	mux.HandleFunc("GET /swagger/models", handleSwaggerModels) // Dynamic model schemas

	// üöÄ UNIFIED AUTOMATIC REGISTRATION - Start the consolidated registration system
	log.Println("üîÑ Initializing unified automatic model registration...")

	// Start unified registration in a goroutine
	ctx := context.Background()
	go func() {
		if err := registry.StartRegistration(ctx, mux); err != nil {
			log.Printf("‚ùå Registration error: %v", err)
		}
	}()

	// Allow some time for initial model scanning
	time.Sleep(1 * time.Second)

	// Create optimized HTTP server
	server := &http.Server{
		Addr:    ":" + port,
		Handler: mux,
		// Optimized timeouts for production use
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	log.Printf("üöÄ Modular server starting on port %s", port)
	log.Printf("üìã Available endpoints:")
	log.Printf("  üìä GET  /health                - Server health check")
	log.Printf("  üîÑ POST /validate              - Generic validation with model type")
	log.Printf("  üìù GET  /models               - List available models")
	log.Printf("  üìö GET  /swagger/             - Swagger UI documentation")
	log.Printf("  üîç GET  /swagger/doc.json     - Swagger JSON specification")
	log.Printf("  üìÑ GET  /swagger/models       - Dynamic model schemas")
	log.Printf("")
	log.Printf("üéØ Platform-specific validation endpoints (AUTO-GENERATED):")

	// Dynamically list all registered model endpoints (after models are loaded)
	log.Printf("  üìÇ Dynamic endpoints will be listed after model discovery completes...")

	if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("Modular server failed to start: %v", err)
	}
}

// handleHealth provides optimized health check with minimal overhead
func handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Simple health response with uptime
	health := map[string]interface{}{
		"status":  "healthy",
		"version": "2.0.0-modular",
		"uptime":  time.Since(startTime).String(),
		"server":  "modular-validation-server",
	}

	json.NewEncoder(w).Encode(health)
}

// NOTE: Individual platform handlers (handleGitHubValidation, etc.)
// are no longer needed as they are automatically generated by the registry system.
// All platform-specific validation is now handled dynamically via registry.RegisterHTTPEndpoints()

// handleGenericValidation handles validation with explicit model type using automatic discovery
func handleGenericValidation(w http.ResponseWriter, r *http.Request) {
	var request struct {
		ModelType string                 `json:"model_type"`
		Payload   map[string]interface{} `json:"payload"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		sendJSONError(w, "Invalid JSON payload", http.StatusBadRequest)
		return
	}

	// Get the registry and check if model type is registered
	globalRegistry := registry.GetGlobalRegistry()
	modelType := registry.ModelType(request.ModelType)

	if !globalRegistry.IsRegistered(modelType) {
		sendJSONError(w, fmt.Sprintf("Model type '%s' is not registered", request.ModelType), http.StatusBadRequest)
		return
	}

	// Create an instance of the model struct
	modelInstance, err := globalRegistry.CreateModelInstance(modelType)
	if err != nil {
		sendJSONError(w, "Failed to create model instance: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Convert map to struct using optimized direct conversion
	if err := convertMapToStruct(request.Payload, modelInstance); err != nil {
		sendJSONError(w, "Failed to parse payload into model struct: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Dereference the pointer to get the actual struct value
	modelValue := reflect.ValueOf(modelInstance).Elem().Interface()

	// Validate using the registry
	result, err := globalRegistry.ValidatePayload(modelType, modelValue)
	if err != nil {
		sendJSONError(w, "Validation failed: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")

	// Check if result indicates invalid payload
	if resultMap, ok := result.(map[string]interface{}); ok {
		if isValid, exists := resultMap["is_valid"]; exists {
			if valid, ok := isValid.(bool); ok && !valid {
				w.WriteHeader(http.StatusUnprocessableEntity)
			}
		}
	}

	json.NewEncoder(w).Encode(result)
}

// handleListModels returns available model types dynamically
func handleListModels(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Try dynamic registry first
	dynamicRegistry := registry.GetGlobalDynamicRegistry()
	if dynamicRegistry != nil {
		modelsWithDetails := dynamicRegistry.GetRegisteredModelsWithDetails()
		json.NewEncoder(w).Encode(modelsWithDetails)
		return
	}

	// Fallback to standard registry
	standardRegistry := registry.GetGlobalRegistry()
	allModels := standardRegistry.GetAllModels()

	modelList := make([]string, 0, len(allModels))
	for modelType := range allModels {
		modelList = append(modelList, string(modelType))
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"models": modelList,
		"count":  len(modelList),
		"source": "standard_registry",
	})
}

// sendJSONError sends a standardized JSON error response
func sendJSONError(w http.ResponseWriter, message string, status int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error":  message,
		"status": status,
	})
}

// convertMapToStruct efficiently converts a map to a struct using reflection
// This replaces the inefficient JSON marshal/unmarshal pattern
func convertMapToStruct(src map[string]interface{}, dest interface{}) error {
	destValue := reflect.ValueOf(dest)
	if destValue.Kind() != reflect.Ptr || destValue.Elem().Kind() != reflect.Struct {
		return fmt.Errorf("destination must be a pointer to a struct")
	}

	destValue = destValue.Elem()
	destType := destValue.Type()

	for i := 0; i < destValue.NumField(); i++ {
		field := destValue.Field(i)
		fieldType := destType.Field(i)

		// Skip unexported fields
		if !field.CanSet() {
			continue
		}

		// Get the JSON tag name, fall back to field name
		jsonTag := fieldType.Tag.Get("json")
		if jsonTag == "" || jsonTag == "-" {
			continue
		}

		// Handle json tag with options like "field_name,omitempty"
		fieldName := strings.Split(jsonTag, ",")[0]
		if fieldName == "" {
			fieldName = fieldType.Name
		}

		// Get value from source map
		srcValue, exists := src[fieldName]
		if !exists {
			continue
		}

		// Convert and set the value
		if err := setFieldValue(field, srcValue); err != nil {
			return fmt.Errorf("failed to set field %s: %v", fieldName, err)
		}
	}

	return nil
}

// setFieldValue sets a reflect.Value with type conversion
func setFieldValue(field reflect.Value, value interface{}) error {
	if value == nil {
		return nil
	}

	srcValue := reflect.ValueOf(value)
	fieldType := field.Type()

	// Direct assignment if types match
	if srcValue.Type().AssignableTo(fieldType) {
		field.Set(srcValue)
		return nil
	}

	// Handle type conversions
	switch fieldType.Kind() {
	case reflect.String:
		if str, ok := value.(string); ok {
			field.SetString(str)
		} else {
			field.SetString(fmt.Sprintf("%v", value))
		}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		if num, ok := convertToInt64(value); ok {
			if field.OverflowInt(num) {
				return fmt.Errorf("integer overflow for value %v", value)
			}
			field.SetInt(num)
		} else {
			return fmt.Errorf("cannot convert %v to integer", value)
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		if num, ok := convertToUint64(value); ok {
			if field.OverflowUint(num) {
				return fmt.Errorf("unsigned integer overflow for value %v", value)
			}
			field.SetUint(num)
		} else {
			return fmt.Errorf("cannot convert %v to unsigned integer", value)
		}
	case reflect.Float32, reflect.Float64:
		if num, ok := convertToFloat64(value); ok {
			if field.OverflowFloat(num) {
				return fmt.Errorf("float overflow for value %v", value)
			}
			field.SetFloat(num)
		} else {
			return fmt.Errorf("cannot convert %v to float", value)
		}
	case reflect.Bool:
		if b, ok := value.(bool); ok {
			field.SetBool(b)
		} else {
			return fmt.Errorf("cannot convert %v to bool", value)
		}
	case reflect.Slice:
		return setSliceValue(field, value)
	case reflect.Map:
		return setMapValue(field, value)
	default:
		// Fall back to JSON conversion for complex types
		jsonBytes, err := json.Marshal(value)
		if err != nil {
			return err
		}
		return json.Unmarshal(jsonBytes, field.Addr().Interface())
	}

	return nil
}

// Helper functions for type conversion
func convertToInt64(value interface{}) (int64, bool) {
	switch v := value.(type) {
	case int:
		return int64(v), true
	case int8:
		return int64(v), true
	case int16:
		return int64(v), true
	case int32:
		return int64(v), true
	case int64:
		return v, true
	case float32:
		return int64(v), true
	case float64:
		return int64(v), true
	case string:
		if i, err := fmt.Sscanf(v, "%d", new(int64)); err == nil && i == 1 {
			var result int64
			fmt.Sscanf(v, "%d", &result)
			return result, true
		}
	}
	return 0, false
}

func convertToUint64(value interface{}) (uint64, bool) {
	switch v := value.(type) {
	case uint:
		return uint64(v), true
	case uint8:
		return uint64(v), true
	case uint16:
		return uint64(v), true
	case uint32:
		return uint64(v), true
	case uint64:
		return v, true
	case int:
		if v >= 0 {
			return uint64(v), true
		}
	case int64:
		if v >= 0 {
			return uint64(v), true
		}
	case float64:
		if v >= 0 {
			return uint64(v), true
		}
	}
	return 0, false
}

func convertToFloat64(value interface{}) (float64, bool) {
	switch v := value.(type) {
	case float32:
		return float64(v), true
	case float64:
		return v, true
	case int:
		return float64(v), true
	case int64:
		return float64(v), true
	case uint64:
		return float64(v), true
	case string:
		if f, err := fmt.Sscanf(v, "%f", new(float64)); err == nil && f == 1 {
			var result float64
			fmt.Sscanf(v, "%f", &result)
			return result, true
		}
	}
	return 0, false
}

func setSliceValue(field reflect.Value, value interface{}) error {
	srcSlice := reflect.ValueOf(value)
	if srcSlice.Kind() != reflect.Slice {
		return fmt.Errorf("source is not a slice")
	}

	sliceType := field.Type()
	newSlice := reflect.MakeSlice(sliceType, srcSlice.Len(), srcSlice.Len())

	for i := 0; i < srcSlice.Len(); i++ {
		if err := setFieldValue(newSlice.Index(i), srcSlice.Index(i).Interface()); err != nil {
			return err
		}
	}

	field.Set(newSlice)
	return nil
}

func setMapValue(field reflect.Value, value interface{}) error {
	srcMap := reflect.ValueOf(value)
	if srcMap.Kind() != reflect.Map {
		return fmt.Errorf("source is not a map")
	}

	mapType := field.Type()
	newMap := reflect.MakeMap(mapType)

	for _, key := range srcMap.MapKeys() {
		mapValue := srcMap.MapIndex(key)
		newValue := reflect.New(mapType.Elem()).Elem()

		if err := setFieldValue(newValue, mapValue.Interface()); err != nil {
			return err
		}

		newMap.SetMapIndex(key, newValue)
	}

	field.Set(newMap)
	return nil
}

// handleSwaggerJSON serves the Swagger JSON specification
func handleSwaggerJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Read the swagger.yaml file and convert to JSON format
	swaggerSpec := getSwaggerSpec()
	json.NewEncoder(w).Encode(swaggerSpec)
}

// handleSwaggerModels returns dynamic model schemas based on registered models
func handleSwaggerModels(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Try dynamic registry first
	dynamicRegistry := registry.GetGlobalDynamicRegistry()
	if dynamicRegistry != nil {
		modelsWithDetails := dynamicRegistry.GetRegisteredModelsWithDetails()
		json.NewEncoder(w).Encode(modelsWithDetails)
		return
	}

	// Fallback to standard registry
	models := registry.GetGlobalRegistry().GetAllModels()

	// Create dynamic schemas for each model
	dynamicSchemas := make(map[string]interface{})
	for modelType, modelInfo := range models {
		dynamicSchemas[string(modelType)] = map[string]interface{}{
			"type":        "object",
			"description": modelInfo.Description,
			"version":     modelInfo.Version,
			"author":      modelInfo.Author,
			"tags":        modelInfo.Tags,
			"examples":    modelInfo.Examples,
			"created_at":  modelInfo.CreatedAt,
			"endpoint":    "/validate/" + string(modelType),
		}
	}

	response := map[string]interface{}{
		"models":      dynamicSchemas,
		"count":       len(dynamicSchemas),
		"last_update": time.Now().Format(time.RFC3339),
		"source":      "standard_registry",
	}

	json.NewEncoder(w).Encode(response)
}

// getSwaggerSpec returns the Swagger specification as a Go map
func getSwaggerSpec() map[string]interface{} {
	// Get dynamic model list
	var modelList []string

	// Try dynamic registry first
	dynamicRegistry := registry.GetGlobalDynamicRegistry()
	if dynamicRegistry != nil {
		allModels := dynamicRegistry.GetAllModels()
		modelList = make([]string, 0, len(allModels))
		for modelType := range allModels {
			modelList = append(modelList, string(modelType))
		}
	} else {
		// Fallback to standard registry
		models := registry.GetGlobalRegistry().ListModels()
		modelList = make([]string, len(models))
		for i, model := range models {
			modelList[i] = string(model)
		}
	}

	// Basic Swagger spec structure that will be populated from swagger.yaml
	return map[string]interface{}{
		"openapi": "3.0.3",
		"info": map[string]interface{}{
			"title":       "Modular Multi-Platform Validation API",
			"description": "A comprehensive modular validation server supporting multiple platforms and data formats.",
			"version":     "2.0.0-modular",
		},
		"servers": []map[string]interface{}{
			{"url": "http://localhost:8080", "description": "Development server"},
		},
		"paths": map[string]interface{}{
			"/health": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "Health check endpoint",
					"description": "Returns the current health status of the modular validation server",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Server is healthy",
						},
					},
				},
			},
			"/models": map[string]interface{}{
				"get": map[string]interface{}{
					"summary":     "List available model types",
					"description": "Returns all available model types that can be validated",
					"tags":        []string{"System"},
					"responses": map[string]interface{}{
						"200": map[string]interface{}{
							"description": "Available model types",
						},
					},
				},
			},
		},
		"tags": []map[string]interface{}{
			{"name": "System", "description": "System health, status and model discovery"},
			{"name": "Platform Validation", "description": "Platform-specific validation endpoints"},
			{"name": "Generic Validation", "description": "Generic validation with automatic type conversion"},
		},
		"components": map[string]interface{}{
			"schemas": map[string]interface{}{
				"available_models": modelList,
			},
		},
	}
}
